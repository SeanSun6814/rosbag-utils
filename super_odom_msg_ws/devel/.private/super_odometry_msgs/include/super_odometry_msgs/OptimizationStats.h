// Generated by gencpp from file super_odometry_msgs/OptimizationStats.msg
// DO NOT EDIT!


#ifndef SUPER_ODOMETRY_MSGS_MESSAGE_OPTIMIZATIONSTATS_H
#define SUPER_ODOMETRY_MSGS_MESSAGE_OPTIMIZATIONSTATS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <super_odometry_msgs/IterationStats.h>

namespace super_odometry_msgs
{
template <class ContainerAllocator>
struct OptimizationStats_
{
  typedef OptimizationStats_<ContainerAllocator> Type;

  OptimizationStats_()
    : header()
    , laserCloudSurfFromMapNum(0)
    , laserCloudCornerFromMapNum(0)
    , laserCloudSurfStackNum(0)
    , laserCloudCornerStackNum(0)
    , total_translation(0.0)
    , total_rotation(0.0)
    , translation_from_last(0.0)
    , rotation_from_last(0.0)
    , time_elapsed(0.0)
    , latency(0.0)
    , n_iterations(0)
    , average_distance(0.0)
    , uncertainty_x(0.0)
    , uncertainty_y(0.0)
    , uncertainty_z(0.0)
    , uncertainty_roll(0.0)
    , uncertainty_pitch(0.0)
    , uncertainty_yaw(0.0)
    , meanSquareDistEdgeInlierNum(0)
    , meanSquareDistEdgeOutlierNum(0)
    , fitQualityCoeffEdgeInlierNum(0)
    , fitQualityCoeffEdgeOutlierNum(0)
    , meanSquareDistPlaneInlierNum(0)
    , meanSquareDistPlaneOutlierNum(0)
    , fitQualityCoeffPlaneInlierNum(0)
    , fitQualityCoeffPlaneOutlierNum(0)
    , PlaneMatchSuccess(0)
    , PlaneNoEnoughNeighbor(0)
    , PlaneNeighborTooFar(0)
    , PlaneBADPCAStructure(0)
    , PlaneInvalidNumerical(0)
    , PlaneMSETOOLARGE(0)
    , PlaneUnknown(0)
    , PredictionSource(0)
    , iterations()  {
    }
  OptimizationStats_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , laserCloudSurfFromMapNum(0)
    , laserCloudCornerFromMapNum(0)
    , laserCloudSurfStackNum(0)
    , laserCloudCornerStackNum(0)
    , total_translation(0.0)
    , total_rotation(0.0)
    , translation_from_last(0.0)
    , rotation_from_last(0.0)
    , time_elapsed(0.0)
    , latency(0.0)
    , n_iterations(0)
    , average_distance(0.0)
    , uncertainty_x(0.0)
    , uncertainty_y(0.0)
    , uncertainty_z(0.0)
    , uncertainty_roll(0.0)
    , uncertainty_pitch(0.0)
    , uncertainty_yaw(0.0)
    , meanSquareDistEdgeInlierNum(0)
    , meanSquareDistEdgeOutlierNum(0)
    , fitQualityCoeffEdgeInlierNum(0)
    , fitQualityCoeffEdgeOutlierNum(0)
    , meanSquareDistPlaneInlierNum(0)
    , meanSquareDistPlaneOutlierNum(0)
    , fitQualityCoeffPlaneInlierNum(0)
    , fitQualityCoeffPlaneOutlierNum(0)
    , PlaneMatchSuccess(0)
    , PlaneNoEnoughNeighbor(0)
    , PlaneNeighborTooFar(0)
    , PlaneBADPCAStructure(0)
    , PlaneInvalidNumerical(0)
    , PlaneMSETOOLARGE(0)
    , PlaneUnknown(0)
    , PredictionSource(0)
    , iterations(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int32_t _laserCloudSurfFromMapNum_type;
  _laserCloudSurfFromMapNum_type laserCloudSurfFromMapNum;

   typedef int32_t _laserCloudCornerFromMapNum_type;
  _laserCloudCornerFromMapNum_type laserCloudCornerFromMapNum;

   typedef int32_t _laserCloudSurfStackNum_type;
  _laserCloudSurfStackNum_type laserCloudSurfStackNum;

   typedef int32_t _laserCloudCornerStackNum_type;
  _laserCloudCornerStackNum_type laserCloudCornerStackNum;

   typedef double _total_translation_type;
  _total_translation_type total_translation;

   typedef double _total_rotation_type;
  _total_rotation_type total_rotation;

   typedef double _translation_from_last_type;
  _translation_from_last_type translation_from_last;

   typedef double _rotation_from_last_type;
  _rotation_from_last_type rotation_from_last;

   typedef double _time_elapsed_type;
  _time_elapsed_type time_elapsed;

   typedef double _latency_type;
  _latency_type latency;

   typedef int32_t _n_iterations_type;
  _n_iterations_type n_iterations;

   typedef double _average_distance_type;
  _average_distance_type average_distance;

   typedef double _uncertainty_x_type;
  _uncertainty_x_type uncertainty_x;

   typedef double _uncertainty_y_type;
  _uncertainty_y_type uncertainty_y;

   typedef double _uncertainty_z_type;
  _uncertainty_z_type uncertainty_z;

   typedef double _uncertainty_roll_type;
  _uncertainty_roll_type uncertainty_roll;

   typedef double _uncertainty_pitch_type;
  _uncertainty_pitch_type uncertainty_pitch;

   typedef double _uncertainty_yaw_type;
  _uncertainty_yaw_type uncertainty_yaw;

   typedef int32_t _meanSquareDistEdgeInlierNum_type;
  _meanSquareDistEdgeInlierNum_type meanSquareDistEdgeInlierNum;

   typedef int32_t _meanSquareDistEdgeOutlierNum_type;
  _meanSquareDistEdgeOutlierNum_type meanSquareDistEdgeOutlierNum;

   typedef int32_t _fitQualityCoeffEdgeInlierNum_type;
  _fitQualityCoeffEdgeInlierNum_type fitQualityCoeffEdgeInlierNum;

   typedef int32_t _fitQualityCoeffEdgeOutlierNum_type;
  _fitQualityCoeffEdgeOutlierNum_type fitQualityCoeffEdgeOutlierNum;

   typedef int32_t _meanSquareDistPlaneInlierNum_type;
  _meanSquareDistPlaneInlierNum_type meanSquareDistPlaneInlierNum;

   typedef int32_t _meanSquareDistPlaneOutlierNum_type;
  _meanSquareDistPlaneOutlierNum_type meanSquareDistPlaneOutlierNum;

   typedef int32_t _fitQualityCoeffPlaneInlierNum_type;
  _fitQualityCoeffPlaneInlierNum_type fitQualityCoeffPlaneInlierNum;

   typedef int32_t _fitQualityCoeffPlaneOutlierNum_type;
  _fitQualityCoeffPlaneOutlierNum_type fitQualityCoeffPlaneOutlierNum;

   typedef int32_t _PlaneMatchSuccess_type;
  _PlaneMatchSuccess_type PlaneMatchSuccess;

   typedef int32_t _PlaneNoEnoughNeighbor_type;
  _PlaneNoEnoughNeighbor_type PlaneNoEnoughNeighbor;

   typedef int32_t _PlaneNeighborTooFar_type;
  _PlaneNeighborTooFar_type PlaneNeighborTooFar;

   typedef int32_t _PlaneBADPCAStructure_type;
  _PlaneBADPCAStructure_type PlaneBADPCAStructure;

   typedef int32_t _PlaneInvalidNumerical_type;
  _PlaneInvalidNumerical_type PlaneInvalidNumerical;

   typedef int32_t _PlaneMSETOOLARGE_type;
  _PlaneMSETOOLARGE_type PlaneMSETOOLARGE;

   typedef int32_t _PlaneUnknown_type;
  _PlaneUnknown_type PlaneUnknown;

   typedef int32_t _PredictionSource_type;
  _PredictionSource_type PredictionSource;

   typedef std::vector< ::super_odometry_msgs::IterationStats_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::super_odometry_msgs::IterationStats_<ContainerAllocator> >> _iterations_type;
  _iterations_type iterations;





  typedef boost::shared_ptr< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> const> ConstPtr;

}; // struct OptimizationStats_

typedef ::super_odometry_msgs::OptimizationStats_<std::allocator<void> > OptimizationStats;

typedef boost::shared_ptr< ::super_odometry_msgs::OptimizationStats > OptimizationStatsPtr;
typedef boost::shared_ptr< ::super_odometry_msgs::OptimizationStats const> OptimizationStatsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator1> & lhs, const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.laserCloudSurfFromMapNum == rhs.laserCloudSurfFromMapNum &&
    lhs.laserCloudCornerFromMapNum == rhs.laserCloudCornerFromMapNum &&
    lhs.laserCloudSurfStackNum == rhs.laserCloudSurfStackNum &&
    lhs.laserCloudCornerStackNum == rhs.laserCloudCornerStackNum &&
    lhs.total_translation == rhs.total_translation &&
    lhs.total_rotation == rhs.total_rotation &&
    lhs.translation_from_last == rhs.translation_from_last &&
    lhs.rotation_from_last == rhs.rotation_from_last &&
    lhs.time_elapsed == rhs.time_elapsed &&
    lhs.latency == rhs.latency &&
    lhs.n_iterations == rhs.n_iterations &&
    lhs.average_distance == rhs.average_distance &&
    lhs.uncertainty_x == rhs.uncertainty_x &&
    lhs.uncertainty_y == rhs.uncertainty_y &&
    lhs.uncertainty_z == rhs.uncertainty_z &&
    lhs.uncertainty_roll == rhs.uncertainty_roll &&
    lhs.uncertainty_pitch == rhs.uncertainty_pitch &&
    lhs.uncertainty_yaw == rhs.uncertainty_yaw &&
    lhs.meanSquareDistEdgeInlierNum == rhs.meanSquareDistEdgeInlierNum &&
    lhs.meanSquareDistEdgeOutlierNum == rhs.meanSquareDistEdgeOutlierNum &&
    lhs.fitQualityCoeffEdgeInlierNum == rhs.fitQualityCoeffEdgeInlierNum &&
    lhs.fitQualityCoeffEdgeOutlierNum == rhs.fitQualityCoeffEdgeOutlierNum &&
    lhs.meanSquareDistPlaneInlierNum == rhs.meanSquareDistPlaneInlierNum &&
    lhs.meanSquareDistPlaneOutlierNum == rhs.meanSquareDistPlaneOutlierNum &&
    lhs.fitQualityCoeffPlaneInlierNum == rhs.fitQualityCoeffPlaneInlierNum &&
    lhs.fitQualityCoeffPlaneOutlierNum == rhs.fitQualityCoeffPlaneOutlierNum &&
    lhs.PlaneMatchSuccess == rhs.PlaneMatchSuccess &&
    lhs.PlaneNoEnoughNeighbor == rhs.PlaneNoEnoughNeighbor &&
    lhs.PlaneNeighborTooFar == rhs.PlaneNeighborTooFar &&
    lhs.PlaneBADPCAStructure == rhs.PlaneBADPCAStructure &&
    lhs.PlaneInvalidNumerical == rhs.PlaneInvalidNumerical &&
    lhs.PlaneMSETOOLARGE == rhs.PlaneMSETOOLARGE &&
    lhs.PlaneUnknown == rhs.PlaneUnknown &&
    lhs.PredictionSource == rhs.PredictionSource &&
    lhs.iterations == rhs.iterations;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator1> & lhs, const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace super_odometry_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
{
  static const char* value()
  {
    return "db5910f4dcadf7d411c357fed874db59";
  }

  static const char* value(const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xdb5910f4dcadf7d4ULL;
  static const uint64_t static_value2 = 0x11c357fed874db59ULL;
};

template<class ContainerAllocator>
struct DataType< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
{
  static const char* value()
  {
    return "super_odometry_msgs/OptimizationStats";
  }

  static const char* value(const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"int32 laserCloudSurfFromMapNum\n"
"int32 laserCloudCornerFromMapNum\n"
"int32 laserCloudSurfStackNum\n"
"int32 laserCloudCornerStackNum\n"
"float64 total_translation\n"
"float64 total_rotation\n"
"float64 translation_from_last\n"
"float64 rotation_from_last\n"
"float64 time_elapsed\n"
"float64 latency\n"
"int32 n_iterations \n"
"float64 average_distance \n"
"float64 uncertainty_x\n"
"float64 uncertainty_y\n"
"float64 uncertainty_z\n"
"float64 uncertainty_roll\n"
"float64 uncertainty_pitch\n"
"float64 uncertainty_yaw\n"
"int32 meanSquareDistEdgeInlierNum\n"
"int32 meanSquareDistEdgeOutlierNum\n"
"int32 fitQualityCoeffEdgeInlierNum\n"
"int32 fitQualityCoeffEdgeOutlierNum\n"
"int32 meanSquareDistPlaneInlierNum\n"
"int32 meanSquareDistPlaneOutlierNum\n"
"int32 fitQualityCoeffPlaneInlierNum\n"
"int32 fitQualityCoeffPlaneOutlierNum\n"
"int32  PlaneMatchSuccess\n"
"int32  PlaneNoEnoughNeighbor\n"
"int32  PlaneNeighborTooFar \n"
"int32  PlaneBADPCAStructure\n"
"int32  PlaneInvalidNumerical\n"
"int32  PlaneMSETOOLARGE\n"
"int32  PlaneUnknown\n"
"int32  PredictionSource \n"
"super_odometry_msgs/IterationStats[] iterations\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: super_odometry_msgs/IterationStats\n"
"# float64 time_elapsed\n"
"float64 translation_norm\n"
"float64 rotation_norm\n"
"float64 num_surf_from_scan\n"
"float64 num_corner_from_scan\n"
;
  }

  static const char* value(const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.laserCloudSurfFromMapNum);
      stream.next(m.laserCloudCornerFromMapNum);
      stream.next(m.laserCloudSurfStackNum);
      stream.next(m.laserCloudCornerStackNum);
      stream.next(m.total_translation);
      stream.next(m.total_rotation);
      stream.next(m.translation_from_last);
      stream.next(m.rotation_from_last);
      stream.next(m.time_elapsed);
      stream.next(m.latency);
      stream.next(m.n_iterations);
      stream.next(m.average_distance);
      stream.next(m.uncertainty_x);
      stream.next(m.uncertainty_y);
      stream.next(m.uncertainty_z);
      stream.next(m.uncertainty_roll);
      stream.next(m.uncertainty_pitch);
      stream.next(m.uncertainty_yaw);
      stream.next(m.meanSquareDistEdgeInlierNum);
      stream.next(m.meanSquareDistEdgeOutlierNum);
      stream.next(m.fitQualityCoeffEdgeInlierNum);
      stream.next(m.fitQualityCoeffEdgeOutlierNum);
      stream.next(m.meanSquareDistPlaneInlierNum);
      stream.next(m.meanSquareDistPlaneOutlierNum);
      stream.next(m.fitQualityCoeffPlaneInlierNum);
      stream.next(m.fitQualityCoeffPlaneOutlierNum);
      stream.next(m.PlaneMatchSuccess);
      stream.next(m.PlaneNoEnoughNeighbor);
      stream.next(m.PlaneNeighborTooFar);
      stream.next(m.PlaneBADPCAStructure);
      stream.next(m.PlaneInvalidNumerical);
      stream.next(m.PlaneMSETOOLARGE);
      stream.next(m.PlaneUnknown);
      stream.next(m.PredictionSource);
      stream.next(m.iterations);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct OptimizationStats_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::super_odometry_msgs::OptimizationStats_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::super_odometry_msgs::OptimizationStats_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "laserCloudSurfFromMapNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserCloudSurfFromMapNum);
    s << indent << "laserCloudCornerFromMapNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserCloudCornerFromMapNum);
    s << indent << "laserCloudSurfStackNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserCloudSurfStackNum);
    s << indent << "laserCloudCornerStackNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserCloudCornerStackNum);
    s << indent << "total_translation: ";
    Printer<double>::stream(s, indent + "  ", v.total_translation);
    s << indent << "total_rotation: ";
    Printer<double>::stream(s, indent + "  ", v.total_rotation);
    s << indent << "translation_from_last: ";
    Printer<double>::stream(s, indent + "  ", v.translation_from_last);
    s << indent << "rotation_from_last: ";
    Printer<double>::stream(s, indent + "  ", v.rotation_from_last);
    s << indent << "time_elapsed: ";
    Printer<double>::stream(s, indent + "  ", v.time_elapsed);
    s << indent << "latency: ";
    Printer<double>::stream(s, indent + "  ", v.latency);
    s << indent << "n_iterations: ";
    Printer<int32_t>::stream(s, indent + "  ", v.n_iterations);
    s << indent << "average_distance: ";
    Printer<double>::stream(s, indent + "  ", v.average_distance);
    s << indent << "uncertainty_x: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_x);
    s << indent << "uncertainty_y: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_y);
    s << indent << "uncertainty_z: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_z);
    s << indent << "uncertainty_roll: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_roll);
    s << indent << "uncertainty_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_pitch);
    s << indent << "uncertainty_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.uncertainty_yaw);
    s << indent << "meanSquareDistEdgeInlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.meanSquareDistEdgeInlierNum);
    s << indent << "meanSquareDistEdgeOutlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.meanSquareDistEdgeOutlierNum);
    s << indent << "fitQualityCoeffEdgeInlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fitQualityCoeffEdgeInlierNum);
    s << indent << "fitQualityCoeffEdgeOutlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fitQualityCoeffEdgeOutlierNum);
    s << indent << "meanSquareDistPlaneInlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.meanSquareDistPlaneInlierNum);
    s << indent << "meanSquareDistPlaneOutlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.meanSquareDistPlaneOutlierNum);
    s << indent << "fitQualityCoeffPlaneInlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fitQualityCoeffPlaneInlierNum);
    s << indent << "fitQualityCoeffPlaneOutlierNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fitQualityCoeffPlaneOutlierNum);
    s << indent << "PlaneMatchSuccess: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneMatchSuccess);
    s << indent << "PlaneNoEnoughNeighbor: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneNoEnoughNeighbor);
    s << indent << "PlaneNeighborTooFar: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneNeighborTooFar);
    s << indent << "PlaneBADPCAStructure: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneBADPCAStructure);
    s << indent << "PlaneInvalidNumerical: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneInvalidNumerical);
    s << indent << "PlaneMSETOOLARGE: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneMSETOOLARGE);
    s << indent << "PlaneUnknown: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PlaneUnknown);
    s << indent << "PredictionSource: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PredictionSource);
    s << indent << "iterations[]" << std::endl;
    for (size_t i = 0; i < v.iterations.size(); ++i)
    {
      s << indent << "  iterations[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::super_odometry_msgs::IterationStats_<ContainerAllocator> >::stream(s, indent + "    ", v.iterations[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // SUPER_ODOMETRY_MSGS_MESSAGE_OPTIMIZATIONSTATS_H
